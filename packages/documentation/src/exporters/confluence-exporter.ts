/**
 * Confluence Exporter
 * 
 * Exports documents to Confluence wiki format
 */

import type { Document, DocumentSection, ExportOptions, ExportResult } from '../types.js';

export class ConfluenceExporter {
  /**
   * Export document to Confluence storage format
   */
  export(document: Document, options?: ExportOptions): ExportResult {
    try {
      const content = this.renderDocument(document, options);
      
      return {
        success: true,
        format: 'confluence',
        content,
        size: content.length,
      };
    } catch (error) {
      return {
        success: false,
        format: 'confluence',
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private renderDocument(document: Document, options?: ExportOptions): string {
    const parts: string[] = [];

    // Document info panel
    parts.push(this.renderInfoPanel(document));

    // Table of contents
    if (options?.includeToc !== false) {
      parts.push('<ac:structured-macro ac:name="toc">');
      parts.push(`  <ac:parameter ac:name="maxLevel">${options?.tocDepth || 3}</ac:parameter>`);
      parts.push('</ac:structured-macro>');
      parts.push('');
    }

    // Sections
    for (const section of document.sections) {
      parts.push(this.renderSection(section));
    }

    // Footer
    parts.push('<hr/>');
    parts.push(`<p><em>Generated by MigrationPilot | Completeness: ${(document.completeness * 100).toFixed(1)}%</em></p>`);

    return parts.join('\n');
  }

  private renderInfoPanel(document: Document): string {
    return `<ac:structured-macro ac:name="info">
  <ac:rich-text-body>
    <p>
      <strong>Document:</strong> ${this.escapeXml(document.title)}<br/>
      <strong>Version:</strong> ${document.version}<br/>
      <strong>Generated:</strong> ${document.generatedAt.toISOString()}<br/>
      <strong>Confidence:</strong> ${(document.confidenceScore * 100).toFixed(1)}%
    </p>
  </ac:rich-text-body>
</ac:structured-macro>

`;
  }

  private renderSection(section: DocumentSection): string {
    const parts: string[] = [];

    // Heading
    const level = Math.min(section.level + 1, 6);
    parts.push(`<h${level}>${this.escapeXml(section.title)}</h${level}>`);

    // AI confidence warning
    if (section.aiGenerated && section.confidence !== undefined && section.confidence < 0.8) {
      parts.push(`<ac:structured-macro ac:name="warning">
  <ac:rich-text-body>
    <p>This content was AI-generated with ${(section.confidence * 100).toFixed(0)}% confidence. Please review for accuracy.</p>
  </ac:rich-text-body>
</ac:structured-macro>`);
    }

    // Content
    if (section.content) {
      parts.push(this.markdownToConfluence(section.content));
    }

    // Source references (expandable)
    if (section.sourceReferences && section.sourceReferences.length > 0) {
      parts.push(`<ac:structured-macro ac:name="expand">
  <ac:parameter ac:name="title">Source References (${section.sourceReferences.length})</ac:parameter>
  <ac:rich-text-body>
    <ul>
      ${section.sourceReferences.map(ref => 
        `<li>${this.escapeXml(ref.name)}${ref.location ? ` (${ref.location.file}:${ref.location.startLine}-${ref.location.endLine})` : ''}</li>`
      ).join('\n      ')}
    </ul>
  </ac:rich-text-body>
</ac:structured-macro>`);
    }

    // Subsections
    if (section.subsections) {
      for (const subsection of section.subsections) {
        parts.push(this.renderSection(subsection));
      }
    }

    parts.push('');
    return parts.join('\n');
  }

  private markdownToConfluence(markdown: string): string {
    let content = markdown;

    // Code blocks
    content = content.replace(/```(\w*)\n([\s\S]*?)```/g, (_, lang, code) => {
      return `<ac:structured-macro ac:name="code">
  <ac:parameter ac:name="language">${lang || 'text'}</ac:parameter>
  <ac:plain-text-body><![CDATA[${code.trim()}]]></ac:plain-text-body>
</ac:structured-macro>`;
    });

    // Inline code
    content = content.replace(/`([^`]+)`/g, '<code>$1</code>');

    // Tables
    content = this.convertTables(content);

    // Bold
    content = content.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

    // Italic
    content = content.replace(/\*([^*]+)\*/g, '<em>$1</em>');

    // Links
    content = content.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');

    // Headers
    content = content.replace(/^### (.+)$/gm, '<h4>$1</h4>');
    content = content.replace(/^## (.+)$/gm, '<h3>$1</h3>');

    // Lists
    content = content.replace(/^- (.+)$/gm, '<li>$1</li>');
    content = content.replace(/(<li>[\s\S]*?<\/li>)/g, '<ul>$1</ul>');
    // Fix nested lists
    content = content.replace(/<\/ul>\s*<ul>/g, '');

    // Blockquotes (as Confluence note macro)
    content = content.replace(/^> (.+)$/gm, `<ac:structured-macro ac:name="note">
  <ac:rich-text-body><p>$1</p></ac:rich-text-body>
</ac:structured-macro>`);

    // Paragraphs
    content = content.replace(/\n\n/g, '</p>\n<p>');
    content = `<p>${content}</p>`;

    // Clean up empty paragraphs
    content = content.replace(/<p>\s*<\/p>/g, '');

    return content;
  }

  private convertTables(markdown: string): string {
    const tableRegex = /\|(.+)\|\n\|[-| ]+\|\n((?:\|.+\|\n?)+)/g;

    return markdown.replace(tableRegex, (_match, header, body) => {
      const headers = header.split('|')
        .filter((c: string) => c.trim())
        .map((c: string) => `<th><p>${this.escapeXml(c.trim())}</p></th>`)
        .join('');

      const rows = body.trim().split('\n').map((row: string) => {
        const cells = row.split('|')
          .filter((c: string) => c.trim())
          .map((c: string) => `<td><p>${this.escapeXml(c.trim())}</p></td>`)
          .join('');
        return `<tr>${cells}</tr>`;
      }).join('\n');

      return `<table>
  <tbody>
    <tr>${headers}</tr>
    ${rows}
  </tbody>
</table>`;
    });
  }

  private escapeXml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }
}
