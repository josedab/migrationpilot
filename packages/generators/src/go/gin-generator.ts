/**
 * Go/Gin Code Generator
 * 
 * Generates idiomatic Go code using the Gin web framework.
 */

import { BaseGenerator } from '../base-generator.js';
import type {
  GeneratedFile,
  ModuleDesign,
  GeneratorBusinessRule,
  GeneratorDataStructure,
} from '../types.js';

export class GinGenerator extends BaseGenerator {
  
  protected getFileExtension(): string {
    return '.go';
  }

  protected mapType(legacyType: string): string {
    const typeMap: Record<string, string> = {
      'PIC 9': 'int',
      'PIC 99': 'int',
      'PIC 9(n)': 'int64',
      'PIC S9': 'int',
      'PIC X': 'string',
      'PIC X(n)': 'string',
      'PIC 9V99': 'float64',
      'COMP': 'int32',
      'COMP-3': 'float64',
      'INTEGER': 'int',
      'REAL': 'float32',
      'DOUBLE PRECISION': 'float64',
      'CHARACTER': 'string',
      'String': 'string',
      'Integer': 'int',
      'Currency': 'float64',
      'Date': 'time.Time',
      'Boolean': 'bool',
    };
    return typeMap[legacyType] || 'interface{}';
  }

  protected generateModels(structures: GeneratorDataStructure[]): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    
    // Generate models.go with all structs
    const modelsContent = this.generateModelsFile(structures);
    files.push({
      path: `${this.config.outputDir}/internal/models/models.go`,
      content: modelsContent,
      type: 'model',
    });

    // Generate DTOs for API requests/responses
    const dtosContent = this.generateDTOsFile(structures);
    files.push({
      path: `${this.config.outputDir}/internal/dto/dto.go`,
      content: dtosContent,
      type: 'model',
    });

    return files;
  }

  private generateModelsFile(structures: GeneratorDataStructure[]): string {
    // Package name derived from config for consistency
    void this.getPackageName();
    
    return `// Package models contains database entity definitions
// Generated by MigrationPilot
package models

import (
	"time"

	"gorm.io/gorm"
)

${structures.map(s => this.generateGoStruct(s, true)).join('\n\n')}
`;
  }

  private generateDTOsFile(structures: GeneratorDataStructure[]): string {
    return `// Package dto contains data transfer objects for API
// Generated by MigrationPilot
package dto

import "time"

${structures.map(s => this.generateDTOStruct(s)).join('\n\n')}
`;
  }

  private generateGoStruct(structure: GeneratorDataStructure, withGorm = false): string {
    const structName = this.toPascalCase(structure.name);
    const fields = structure.fields || [];
    
    const gormFields = withGorm ? `	ID        string         \`gorm:"primaryKey;type:uuid;default:gen_random_uuid()" json:"id"\`
	CreatedAt time.Time      \`json:"created_at"\`
	UpdatedAt time.Time      \`json:"updated_at"\`
	DeletedAt gorm.DeletedAt \`gorm:"index" json:"-"\`
` : '';

    return `// ${structName} represents ${structure.description || structure.name}
// Source: ${structure.sourceLocation?.file || 'legacy code'}
type ${structName} struct {
${gormFields}${fields.map(f => this.generateGoField(f, withGorm)).join('\n')}
}

// TableName returns the database table name for ${structName}
func (${structName}) TableName() string {
	return "${this.toSnakeCase(structure.name)}"
}`;
  }

  private generateDTOStruct(structure: GeneratorDataStructure): string {
    const structName = this.toPascalCase(structure.name);
    const fields = structure.fields || [];

    return `// Create${structName}Request is the DTO for creating a ${structName}
type Create${structName}Request struct {
${fields.filter(f => f.name.toLowerCase() !== 'id').map(f => this.generateGoField(f, false, true)).join('\n')}
}

// Update${structName}Request is the DTO for updating a ${structName}
type Update${structName}Request struct {
${fields.filter(f => f.name.toLowerCase() !== 'id').map(f => this.generateGoField(f, false, true, true)).join('\n')}
}

// ${structName}Response is the API response for ${structName}
type ${structName}Response struct {
	ID        string    \`json:"id"\`
${fields.map(f => this.generateGoField(f, false)).join('\n')}
	CreatedAt time.Time \`json:"created_at"\`
	UpdatedAt time.Time \`json:"updated_at"\`
}`;
  }

  private generateGoField(
    field: { name: string; type: string; description?: string; nullable?: boolean },
    withGorm = false,
    required = false,
    pointer = false
  ): string {
    const goType = this.mapType(field.type);
    const fieldName = this.toPascalCase(field.name);
    const jsonName = this.toSnakeCase(field.name);
    const nullable = field.nullable !== false;
    
    let tags = `json:"${jsonName}${nullable && !required ? ',omitempty' : ''}"`;
    
    if (withGorm) {
      const gormTag = `gorm:"column:${jsonName}${nullable ? '' : ';not null'}"`;
      tags = `${gormTag} ${tags}`;
    }

    if (required) {
      tags += ` binding:"required"`;
    }

    const typeStr = pointer && nullable ? `*${goType}` : goType;
    const comment = field.description ? ` // ${field.description}` : '';
    
    return `	${fieldName} ${typeStr} \`${tags}\`${comment}`;
  }

  protected generateInterfaces(design: ModuleDesign): GeneratedFile[] {
    const content = this.generateServiceInterfaces(design);
    return [{
      path: `${this.config.outputDir}/internal/service/interfaces.go`,
      content,
      type: 'interface',
    }];
  }

  private generateServiceInterfaces(design: ModuleDesign): string {
    return `// Package service contains business logic interfaces and implementations
// Generated by MigrationPilot
package service

import (
	"context"

	"${this.config.packageName}/internal/dto"
	"${this.config.packageName}/internal/models"
)

${design.services.map(s => {
  const interfaceName = this.toPascalCase(s.name) + 'Service';
  return `// ${interfaceName} defines the interface for ${s.name} operations
type ${interfaceName} interface {
${(s.endpoints || []).map(e => {
  const methodName = this.toPascalCase(e.path.replace(/\//g, '_'));
  return `	// ${methodName} ${e.description}
	${methodName}(ctx context.Context${e.requestBody ? `, req *dto.${e.requestBody}` : ''}) (*dto.${e.responseType}, error)`;
}).join('\n')}
}`;
}).join('\n\n')}
`;
  }

  protected generateServices(
    design: ModuleDesign,
    rules: GeneratorBusinessRule[]
  ): GeneratedFile[] {
    const files: GeneratedFile[] = [];

    // Generate main.go
    const mainContent = this.generateMain(design);
    files.push({
      path: `${this.config.outputDir}/cmd/server/main.go`,
      content: mainContent,
      type: 'source',
    });

    // Generate router
    const routerContent = this.generateRouter(design);
    files.push({
      path: `${this.config.outputDir}/internal/router/router.go`,
      content: routerContent,
      type: 'source',
    });

    // Generate handlers
    const handlersContent = this.generateHandlers(design);
    files.push({
      path: `${this.config.outputDir}/internal/handler/handlers.go`,
      content: handlersContent,
      type: 'controller',
    });

    // Generate business rules service
    const rulesContent = this.generateBusinessRulesService(rules);
    files.push({
      path: `${this.config.outputDir}/internal/service/business_rules.go`,
      content: rulesContent,
      type: 'service',
    });

    // Generate repository
    const repoContent = this.generateRepository(design);
    files.push({
      path: `${this.config.outputDir}/internal/repository/repository.go`,
      content: repoContent,
      type: 'repository',
    });

    // Generate go.mod
    const goModContent = this.generateGoMod();
    files.push({
      path: `${this.config.outputDir}/go.mod`,
      content: goModContent,
      type: 'config',
    });

    return files;
  }

  private generateMain(design: ModuleDesign): string {
    return `// Main entry point for the ${design.name} service
// Generated by MigrationPilot
package main

import (
	"log"
	"os"

	"github.com/gin-gonic/gin"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"

	"${this.config.packageName}/internal/handler"
	"${this.config.packageName}/internal/repository"
	"${this.config.packageName}/internal/router"
	"${this.config.packageName}/internal/service"
)

func main() {
	// Database connection
	dsn := os.Getenv("DATABASE_URL")
	if dsn == "" {
		dsn = "host=localhost user=postgres password=postgres dbname=${this.toSnakeCase(design.name)} port=5432 sslmode=disable"
	}

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}

	// Initialize layers
	repo := repository.NewRepository(db)
	svc := service.NewBusinessRulesService(repo)
	h := handler.NewHandler(svc)

	// Setup router
	r := gin.Default()
	router.SetupRoutes(r, h)

	// Start server
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("Starting ${design.name} service on port %s", port)
	if err := r.Run(":" + port); err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}
`;
  }

  private generateRouter(design: ModuleDesign): string {
    const endpoints = design.services.flatMap(s => s.endpoints || []);
    
    return `// Package router sets up API routes
// Generated by MigrationPilot
package router

import (
	"github.com/gin-gonic/gin"

	"${this.config.packageName}/internal/handler"
)

// SetupRoutes configures all API routes
func SetupRoutes(r *gin.Engine, h *handler.Handler) {
	// Health check
	r.GET("/health", func(c *gin.Context) {
		c.JSON(200, gin.H{"status": "healthy"})
	})

	// API routes
	api := r.Group("/api/v1")
	{
${endpoints.map(e => {
  const methodName = this.toPascalCase(e.path.replace(/\//g, '_'));
  return `		api.${e.method}("${e.path}", h.${methodName})`;
}).join('\n')}
	}
}
`;
  }

  private generateHandlers(design: ModuleDesign): string {
    const endpoints = design.services.flatMap(s => s.endpoints || []);
    
    return `// Package handler contains HTTP request handlers
// Generated by MigrationPilot
package handler

import (
	"net/http"

	"github.com/gin-gonic/gin"

	"${this.config.packageName}/internal/dto"
	"${this.config.packageName}/internal/service"
)

// Handler manages HTTP requests
type Handler struct {
	svc *service.BusinessRulesService
}

// NewHandler creates a new Handler
func NewHandler(svc *service.BusinessRulesService) *Handler {
	return &Handler{svc: svc}
}

${endpoints.map(e => this.generateHandlerMethod(e)).join('\n\n')}
`;
  }

  private generateHandlerMethod(endpoint: { path: string; method: string; description: string; requestBody?: string; responseType: string }): string {
    const methodName = this.toPascalCase(endpoint.path.replace(/\//g, '_'));
    
    return `// ${methodName} handles ${endpoint.method} ${endpoint.path}
// ${endpoint.description}
func (h *Handler) ${methodName}(c *gin.Context) {
${endpoint.requestBody ? `	var req dto.${endpoint.requestBody}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	result, err := h.svc.${methodName}(c.Request.Context(), &req)` : `	result, err := h.svc.${methodName}(c.Request.Context())`}
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, result)
}`;
  }

  private generateBusinessRulesService(rules: GeneratorBusinessRule[]): string {
    return `// Package service implements business logic
// Generated by MigrationPilot
package service

import (
	"context"
	"log"

	"${this.config.packageName}/internal/repository"
)

// BusinessRulesService implements extracted business rules
type BusinessRulesService struct {
	repo *repository.Repository
}

// NewBusinessRulesService creates a new BusinessRulesService
func NewBusinessRulesService(repo *repository.Repository) *BusinessRulesService {
	return &BusinessRulesService{repo: repo}
}

${rules.map(r => this.generateGoRuleMethod(r)).join('\n\n')}
`;
  }

  private generateGoRuleMethod(rule: GeneratorBusinessRule): string {
    const methodName = this.toPascalCase(rule.name.replace(/\s+/g, '_'));
    const inputs = rule.inputs || [];
    const output = rule.outputs?.[0];
    
    const params = inputs.map(i => `${this.toCamelCase(i.name)} ${this.mapType(i.type)}`).join(', ');
    const returnType = output ? this.mapType(output.type) : '';
    const returnSignature = returnType ? `(${returnType}, error)` : 'error';

    return `// ${methodName} implements business rule: ${rule.name}
//
// ${rule.description}
//
// Rule ID: ${rule.id}
// Source: ${rule.sourceLocation?.file || 'N/A'}:${rule.sourceLocation?.startLine || 'N/A'}-${rule.sourceLocation?.endLine || 'N/A'}
// Confidence: ${(rule.confidence * 100).toFixed(1)}%
${inputs.map(i => `// @param ${this.toCamelCase(i.name)} ${i.description || i.name}`).join('\n')}
${output ? `// @return ${output.description || output.name}` : ''}
func (s *BusinessRulesService) ${methodName}(ctx context.Context${params ? ', ' + params : ''}) ${returnSignature} {
	log.Printf("Executing rule ${rule.id}: ${rule.name}")

	// Business logic from source:
	// ${rule.logic?.calculation?.split('\n').join('\n\t// ') || 'No calculation defined'}

	// TODO: Implement extracted logic
	${returnType ? `return ${this.getGoDefaultValue(returnType)}, nil` : 'return nil'}
}`;
  }

  private generateRepository(_design: ModuleDesign): string {
    return `// Package repository handles database operations
// Generated by MigrationPilot
package repository

import (
	"context"

	"gorm.io/gorm"

	"${this.config.packageName}/internal/models"
)

// Repository handles database operations
type Repository struct {
	db *gorm.DB
}

// NewRepository creates a new Repository
func NewRepository(db *gorm.DB) *Repository {
	return &Repository{db: db}
}

// AutoMigrate runs database migrations
func (r *Repository) AutoMigrate() error {
	return r.db.AutoMigrate(
		// Add model types here
	)
}

// Generic CRUD operations

// Create inserts a new record
func (r *Repository) Create(ctx context.Context, entity interface{}) error {
	return r.db.WithContext(ctx).Create(entity).Error
}

// FindByID retrieves a record by ID
func (r *Repository) FindByID(ctx context.Context, dest interface{}, id string) error {
	return r.db.WithContext(ctx).First(dest, "id = ?", id).Error
}

// Update modifies an existing record
func (r *Repository) Update(ctx context.Context, entity interface{}) error {
	return r.db.WithContext(ctx).Save(entity).Error
}

// Delete removes a record
func (r *Repository) Delete(ctx context.Context, entity interface{}) error {
	return r.db.WithContext(ctx).Delete(entity).Error
}

// List retrieves multiple records with pagination
func (r *Repository) List(ctx context.Context, dest interface{}, offset, limit int) error {
	return r.db.WithContext(ctx).Offset(offset).Limit(limit).Find(dest).Error
}
`;
  }

  private generateGoMod(): string {
    return `module ${this.config.packageName}

go 1.21

require (
	github.com/gin-gonic/gin v1.9.1
	gorm.io/driver/postgres v1.5.4
	gorm.io/gorm v1.25.5
)
`;
  }

  protected generateTests(
    _design: ModuleDesign,
    rules: GeneratorBusinessRule[]
  ): GeneratedFile[] {
    const content = this.generateGoTests(rules);
    return [{
      path: `${this.config.outputDir}/internal/service/business_rules_test.go`,
      content,
      type: 'test',
    }];
  }

  private generateGoTests(rules: GeneratorBusinessRule[]): string {
    return `// Package service tests
// Generated by MigrationPilot
package service

import (
	"context"
	"testing"
)

${rules.map(r => this.generateGoTestCase(r)).join('\n\n')}
`;
  }

  private generateGoTestCase(rule: GeneratorBusinessRule): string {
    const methodName = this.toPascalCase(rule.name.replace(/\s+/g, '_'));
    const testName = `Test${methodName}`;

    return `func ${testName}(t *testing.T) {
	// Arrange
	svc := NewBusinessRulesService(nil) // TODO: Mock repository
	ctx := context.Background()

	t.Run("should implement ${rule.id} correctly", func(t *testing.T) {
		// TODO: Set up test inputs
		
		// Act
		// result, err := svc.${methodName}(ctx, ...)
		
		// Assert
		// if err != nil {
		//     t.Errorf("unexpected error: %v", err)
		// }
		// if result != expected {
		//     t.Errorf("got %v, want %v", result, expected)
		// }
	})

	t.Run("should handle boundary values", func(t *testing.T) {
		// Edge cases: ${rule.edgeCases?.join(', ') || 'None documented'}
	})
}

func ${testName}_TableDriven(t *testing.T) {
	svc := NewBusinessRulesService(nil)
	ctx := context.Background()

	tests := []struct {
		name     string
		// input    InputType
		// expected ExpectedType
		wantErr  bool
	}{
		// TODO: Add test cases
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// result, err := svc.${methodName}(ctx, tt.input)
			// ... assertions
		})
	}
}`;
  }

  // Helper methods
  private getPackageName(): string {
    return this.config.packageName.split('/').pop() || 'app';
  }

  private toPascalCase(name: string): string {
    return name
      .replace(/[^a-zA-Z0-9]+/g, ' ')
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  private toCamelCase(name: string): string {
    const pascal = this.toPascalCase(name);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
  }

  private toSnakeCase(name: string): string {
    return name
      .replace(/[^a-zA-Z0-9]+/g, '_')
      .replace(/([a-z])([A-Z])/g, '$1_$2')
      .toLowerCase();
  }

  private getGoDefaultValue(type: string): string {
    const defaults: Record<string, string> = {
      'int': '0',
      'int32': '0',
      'int64': '0',
      'float32': '0.0',
      'float64': '0.0',
      'string': '""',
      'bool': 'false',
      'time.Time': 'time.Time{}',
      'interface{}': 'nil',
    };
    return defaults[type] || 'nil';
  }
}
