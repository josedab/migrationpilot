/**
 * Python/FastAPI Code Generator
 */

import { BaseGenerator } from '../base-generator.js';
import type { GeneratedFile, ModuleDesign, GeneratorBusinessRule, GeneratorDataStructure } from '../types.js';

export class FastAPIGenerator extends BaseGenerator {
  
  protected getFileExtension(): string {
    return '.py';
  }

  protected mapType(legacyType: string): string {
    const typeMap: Record<string, string> = {
      'PIC 9': 'int',
      'PIC 99': 'int',
      'PIC 9(n)': 'int',
      'PIC S9': 'int',
      'PIC X': 'str',
      'PIC X(n)': 'str',
      'PIC 9V99': 'Decimal',
      'COMP': 'int',
      'COMP-3': 'Decimal',
      'INTEGER': 'int',
      'REAL': 'float',
      'DOUBLE PRECISION': 'float',
      'CHARACTER': 'str',
      'String': 'str',
      'Integer': 'int',
      'Currency': 'Decimal',
      'Date': 'date',
      'Boolean': 'bool',
    };
    return typeMap[legacyType] || 'Any';
  }

  protected generateModels(structures: GeneratorDataStructure[]): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    
    // Generate a single models.py file with all Pydantic models
    const content = this.generateModelsFile(structures);
    files.push({
      path: `${this.config.outputDir}/models.py`,
      content,
      type: 'model',
    });

    return files;
  }

  private generateModelsFile(structures: GeneratorDataStructure[]): string {
    return `"""
Data Models

Pydantic models for request/response validation and database entities.
Generated by MigrationPilot.
"""

from datetime import date, datetime
from decimal import Decimal
from typing import Optional, List, Any
from pydantic import BaseModel, Field
from sqlalchemy import Column, String, Integer, Numeric, Date, DateTime, Boolean
from sqlalchemy.orm import declarative_base

Base = declarative_base()


${structures.map(s => this.generatePydanticModel(s)).join('\n\n')}


${structures.map(s => this.generateSQLAlchemyModel(s)).join('\n\n')}
`;
  }

  private generatePydanticModel(structure: GeneratorDataStructure): string {
    const className = this.toPascalCase(structure.name);
    const fields = structure.fields || [];

    return `class ${className}(BaseModel):
    """
    ${structure.description || structure.name}
    
    Source: ${structure.sourceLocation?.file || 'legacy code'}
    """
    
${fields.map(f => this.generatePydanticField(f)).join('\n')}

    class Config:
        from_attributes = True`;
  }

  private generatePydanticField(field: { name: string; type: string; description?: string; nullable?: boolean }): string {
    const pythonType = this.mapType(field.type);
    const fieldName = this.toSnakeCase(field.name);
    const nullable = field.nullable !== false;
    const typeAnnotation = nullable ? `Optional[${pythonType}]` : pythonType;
    const defaultValue = nullable ? ' = None' : '';
    
    return `    ${fieldName}: ${typeAnnotation}${defaultValue}  # ${field.description || field.name}`;
  }

  private generateSQLAlchemyModel(structure: GeneratorDataStructure): string {
    const className = this.toPascalCase(structure.name) + 'DB';
    const tableName = this.toSnakeCase(structure.name);
    const fields = structure.fields || [];

    return `class ${className}(Base):
    """SQLAlchemy model for ${structure.name}"""
    
    __tablename__ = "${tableName}"
    
    id = Column(String, primary_key=True)
${fields.map(f => this.generateSQLAlchemyField(f)).join('\n')}`;
  }

  private generateSQLAlchemyField(field: { name: string; type: string; nullable?: boolean }): string {
    const fieldName = this.toSnakeCase(field.name);
    const sqlType = this.mapToSQLAlchemyType(field.type);
    const nullable = field.nullable !== false;
    
    return `    ${fieldName} = Column(${sqlType}, nullable=${nullable ? 'True' : 'False'})`;
  }

  private mapToSQLAlchemyType(legacyType: string): string {
    const pythonType = this.mapType(legacyType);
    const typeMap: Record<string, string> = {
      'int': 'Integer',
      'str': 'String(255)',
      'float': 'Numeric(18, 6)',
      'Decimal': 'Numeric(18, 2)',
      'bool': 'Boolean',
      'date': 'Date',
      'datetime': 'DateTime',
    };
    return typeMap[pythonType] || 'String(255)';
  }

  protected generateInterfaces(design: ModuleDesign): GeneratedFile[] {
    // Python uses duck typing, but we can generate abstract base classes
    const content = this.generateAbstractServices(design);
    return [{
      path: `${this.config.outputDir}/services/base.py`,
      content,
      type: 'interface',
    }];
  }

  private generateAbstractServices(design: ModuleDesign): string {
    return `"""
Abstract Service Interfaces

Base classes defining service contracts.
Generated by MigrationPilot.
"""

from abc import ABC, abstractmethod
from typing import Generic, TypeVar, Optional, List
from decimal import Decimal

T = TypeVar('T')


${design.services.map(s => this.generateAbstractService(s)).join('\n\n')}
`;
  }

  private generateAbstractService(service: ModuleDesign['services'][0]): string {
    const className = this.toPascalCase(service.name) + 'ServiceBase';
    
    return `class ${className}(ABC):
    """
    ${service.description}
    
    Business Rules: ${service.businessRules.join(', ')}
    """
    
${(service.endpoints || []).map(e => `    @abstractmethod
    def ${this.toSnakeCase(e.path.replace(/\//g, '_'))}(self${e.requestBody ? ', request: ' + e.requestBody : ''}) -> ${e.responseType}:
        """${e.description}"""
        pass
`).join('\n')}`;
  }

  protected generateServices(
    design: ModuleDesign,
    rules: GeneratorBusinessRule[]
  ): GeneratedFile[] {
    const files: GeneratedFile[] = [];

    // Generate main router
    const routerContent = this.generateRouter(design);
    files.push({
      path: `${this.config.outputDir}/routers/main.py`,
      content: routerContent,
      type: 'controller',
    });

    // Generate business rules service
    const rulesContent = this.generateBusinessRulesService(rules);
    files.push({
      path: `${this.config.outputDir}/services/business_rules.py`,
      content: rulesContent,
      type: 'service',
    });

    // Generate main app
    const appContent = this.generateApp(design);
    files.push({
      path: `${this.config.outputDir}/main.py`,
      content: appContent,
      type: 'source',
    });

    return files;
  }

  private generateRouter(design: ModuleDesign): string {
    return `"""
API Router

FastAPI router with endpoints for migrated functionality.
Generated by MigrationPilot.
"""

from fastapi import APIRouter, Depends, HTTPException, status
from typing import List
from decimal import Decimal
from ..models import *
from ..services.business_rules import BusinessRulesService

router = APIRouter(prefix="/api", tags=["api"])

# Dependency injection
def get_business_rules_service() -> BusinessRulesService:
    return BusinessRulesService()


${design.services.flatMap(s => s.endpoints || []).map(e => `@router.${e.method.toLowerCase()}("${e.path}")
async def ${this.toSnakeCase(e.path.replace(/\//g, '_'))}(
    ${e.requestBody ? `request: ${e.requestBody},` : ''}
    service: BusinessRulesService = Depends(get_business_rules_service)
) -> ${e.responseType}:
    """
    ${e.description}
    """
    # TODO: Implement endpoint logic
    raise HTTPException(status_code=501, detail="Not implemented")

`).join('\n')}
`;
  }

  private generateBusinessRulesService(rules: GeneratorBusinessRule[]): string {
    return `"""
Business Rules Service

Contains implementations of all extracted business rules.
Each method is documented with its source location and rule ID.
Generated by MigrationPilot.
"""

from decimal import Decimal, ROUND_HALF_UP
from datetime import date, datetime
from typing import Optional
import logging

logger = logging.getLogger(__name__)


class BusinessRulesService:
    """
    Service containing all migrated business rules.
    """

${rules.map(r => this.generatePythonRuleMethod(r)).join('\n\n')}
`;
  }

  private generatePythonRuleMethod(rule: GeneratorBusinessRule): string {
    const methodName = this.toSnakeCase(rule.name);
    const inputs = rule.inputs || [];
    const output = rule.outputs?.[0];
    
    const params = inputs.map(i => `${this.toSnakeCase(i.name)}: ${this.mapType(i.type)}`).join(', ');
    const returnType = output ? this.mapType(output.type) : 'None';

    return `    def ${methodName}(self${params ? ', ' + params : ''}) -> ${returnType}:
        """
        ${rule.name}
        
        ${rule.description}
        
        Rule ID: ${rule.id}
        Source: ${rule.sourceLocation?.file || 'N/A'}:${rule.sourceLocation?.startLine || 'N/A'}-${rule.sourceLocation?.endLine || 'N/A'}
        Confidence: ${(rule.confidence * 100).toFixed(1)}%
        
        Args:
${inputs.map(i => `            ${this.toSnakeCase(i.name)}: ${i.description || i.name}`).join('\n')}
        
        Returns:
            ${output ? output.description || output.name : 'None'}
        """
        logger.debug(f"Executing rule ${rule.id}: ${rule.name}")
        
        # Business logic from source:
        # ${rule.logic?.calculation?.split('\n').join('\n        # ') || 'No calculation defined'}
        
        # TODO: Implement extracted logic
        ${returnType !== 'None' ? `return ${this.getPythonDefaultValue(returnType)}` : 'pass'}`;
  }

  private generateApp(design: ModuleDesign): string {
    return `"""
${design.name}

${design.description}
Generated by MigrationPilot.
"""

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from .routers import main

app = FastAPI(
    title="${design.name}",
    description="${design.description}",
    version="1.0.0",
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(main.router)


@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy"}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
`;
  }

  protected generateTests(
    _design: ModuleDesign,
    rules: GeneratorBusinessRule[]
  ): GeneratedFile[] {
    const content = this.generatePytestFile(rules);
    return [{
      path: `${this.config.outputDir}/tests/test_business_rules.py`,
      content,
      type: 'test',
    }];
  }

  private generatePytestFile(rules: GeneratorBusinessRule[]): string {
    return `"""
Business Rules Tests

Pytest test cases for validating behavioral equivalence.
Generated by MigrationPilot.
"""

import pytest
from decimal import Decimal
from datetime import date
from ..services.business_rules import BusinessRulesService


@pytest.fixture
def service():
    """Fixture for BusinessRulesService"""
    return BusinessRulesService()


${rules.map(r => this.generatePytestCase(r)).join('\n\n')}
`;
  }

  private generatePytestCase(rule: GeneratorBusinessRule): string {
    const methodName = this.toSnakeCase(rule.name);
    const testName = `test_${methodName}`;

    return `class Test${this.toPascalCase(rule.name.replace(/\s+/g, '_'))}:
    """Tests for ${rule.name} (${rule.id})"""

    def ${testName}(self, service):
        """Test basic functionality of ${rule.name}"""
        # Arrange
        # TODO: Set up test inputs
        
        # Act
        # result = service.${methodName}(...)
        
        # Assert
        # assert result == expected
        pass

    def ${testName}_boundary_values(self, service):
        """Test boundary conditions"""
        # Edge cases: ${rule.edgeCases?.join(', ') || 'None documented'}
        pass

    @pytest.mark.parametrize("input_val,expected", [
        # TODO: Add parametrized test cases
    ])
    def ${testName}_parametrized(self, service, input_val, expected):
        """Parametrized tests for various inputs"""
        pass`;
  }

  // Helper methods
  private toPascalCase(name: string): string {
    return name
      .replace(/[^a-zA-Z0-9]+/g, ' ')
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  private toSnakeCase(name: string): string {
    return name
      .replace(/[^a-zA-Z0-9]+/g, '_')
      .replace(/([a-z])([A-Z])/g, '$1_$2')
      .toLowerCase()
      .replace(/^_+|_+$/g, '');
  }

  private getPythonDefaultValue(type: string): string {
    const defaults: Record<string, string> = {
      'int': '0',
      'float': '0.0',
      'Decimal': 'Decimal("0")',
      'str': '""',
      'bool': 'False',
      'date': 'date.today()',
      'datetime': 'datetime.now()',
      'List': '[]',
      'dict': '{}',
    };
    return defaults[type] || 'None';
  }
}
